import numpy as np
import scipy.signal 

"""
QPSK Demodulator Pseudocode
Demodulates the signal generated by qpsk-gen.py

Signal characteristics to handle:
- 80 kHz sample rate, 10 kbaud symbol rate (8 samples/symbol)
- RRC pulse shaped (β=0.35, span=10 symbols)
- 500 Hz carrier frequency offset
- Random timing offset (0-1 symbol)
- Random phase offset
- 15 dB SNR AWGN

Receiver block diagram:
RX IQ → Matched Filter → Coarse CFO Correction → Timing Sync →
Fine CFO Correction → Phase Recovery → Symbol Sampling → Demodulation
"""

# ============================================================================
# STEP 1: LOAD IQ FILE
# ============================================================================
"""
TODO: Load the received signal from IQ file

Pseudocode:
1. Open 'qpsk_signal.iq' file
2. Read as complex64 (numpy fromfile)
3. Store in rx_signal array
4. Set known parameters:
   - sample_rate = 80e3 Hz
   - symbol_rate = 10e3 baud
   - sps = 8 samples/symbol
5. Print number of samples loaded

Implementation hints:
- Use np.fromfile(filename, dtype=np.complex64)
- rx_signal will be a 1D numpy array of complex numbers
"""
# Read in signal
import os
file_path = 'qpsk_signal.iq'
file_size = os.path.getsize(file_path)
print(f"File size on disk: {file_size / 1e6:.2f} MB")
rx_signal_array = np.fromfile(file_path, dtype=np.complex64)
sample_rate = 80e3
symbol_rate = 10e3
sps = 8
print(f"Loaded {len(rx_signal_array)} IQ samples from file")

# ============================================================================
# STEP 2: MATCHED FILTER (RRC)
# ============================================================================
"""
TODO: Apply matched filter to maximize SNR

Why: TX used RRC pulse shaping. RX uses same RRC → combined is Raised Cosine
This gives zero Inter-Symbol Interference (ISI) at optimal sampling instant

Pseudocode:
1. Create RRC filter function:
   - Input: sps (8), span (10 symbols), beta (0.35)
   - Generate time vector from -span/2 to +span/2
   - Apply RRC formula at each time point:
     * Special cases: t=0 and t=±1/(4*beta)
     * General case: sinc and cosine terms
   - Normalize filter to unit energy: h = h / sqrt(sum(h^2))
   - Return filter coefficients
"""
   
def rrc_filter(sps, span, beta):
    """
    Generate Root Raised Cosine (RRC) filter coefficients

    Args:
        sps: Samples per symbol
        span: Filter span in symbols
        beta: Roll-off factor (0 < beta <= 1)

    Returns:
        h: RRC filter coefficients
    """
    num_taps = span * sps + 1
    t = np.arange(-span*sps/2, span*sps/2 + 1) / sps

    # RRC formula
    h = np.zeros(len(t))
    for i, time in enumerate(t):
        if time == 0:
            h[i] = (1 + beta*(4/np.pi - 1))
        elif abs(time) == 1/(4*beta):
            h[i] = (beta/np.sqrt(2)) * ((1 + 2/np.pi)*np.sin(np.pi/(4*beta)) +
                                         (1 - 2/np.pi)*np.cos(np.pi/(4*beta)))
        else:
            h[i] = (np.sin(np.pi*time*(1-beta)) +
                    4*beta*time*np.cos(np.pi*time*(1+beta))) / \
                   (np.pi*time*(1 - (4*beta*time)**2))

    # Normalize to unit energy
    h = h / np.sqrt(np.sum(h**2))
    return h

"""
2. Create RRC filter with parameters: sps=8, span=10, beta=0.35
"""

rrc_filter = rrc_filter(8, 10, 0.35)

"""
3. Convolve rx_signal with RRC filter
   - Use scipy.signal.upfirdn or np.convolve

"""

matched_output = scipy.signal.upfirdn(rrc_filter, rx_signal_array, up=1, down=1)

"""
4. Remove filter delay (group delay)
   - Group delay = (filter_length - 1) / 2 samples
   - Trim output to match original signal length

5. Print confirmation

Implementation hints:
- RRC formula: https://en.wikipedia.org/wiki/Root-raised-cosine_filter
- Use np.convolve(signal, filter, mode='full') then trim
- Or use scipy.signal.upfirdn(filter, signal, up=1, down=1)
"""

# YOUR CODE HERE:
# def rrc_filter(sps, span, beta):
#     # Create RRC filter
#     ...
#     return h
#
# rrc = rrc_filter(8, 10, 0.35)
# matched_output = ...  (convolve rx_signal with rrc)
# matched_output = ...  (remove delay)


# ============================================================================
# STEP 3: COARSE CARRIER FREQUENCY OFFSET (CFO) CORRECTION
# ============================================================================
"""
TODO: Estimate and remove large frequency offset (~500 Hz)

Why: TX and RX oscillators not perfectly matched. Creates frequency offset
that rotates constellation. Must correct before symbol decisions.

Method: 4th Power FFT Method

Pseudocode:
1. Take first 4096 samples of matched_output (or any large block)

2. Raise to 4th power:
   - For QPSK: (I+jQ)^4 removes modulation
   - Leaves only carrier tone at 4 × frequency_offset
   - Why 4th power? QPSK has 4-fold rotational symmetry

3. Take FFT of 4th-power signal:
   - Use np.fft.fft()
   - Get frequency bins with np.fft.fftfreq(N, 1/sample_rate)

4. Find peak in FFT magnitude:
   - Peak location = 4 × frequency_offset
   - Use np.argmax(abs(fft_result))

5. Estimate frequency offset:
   - freq_offset_estimate = peak_frequency / 4

6. Correct entire signal:
   - Create time vector: t = [0, 1/fs, 2/fs, ...]
   - Multiply signal by exp(-j*2*π*f_offset*t)
   - This rotates constellation back to correct position

7. Print estimated offset

Implementation hints:
- Complex exponential: np.exp(1j * 2 * np.pi * f * t)
- Element-wise multiplication: signal * correction_term
- FFT gives both positive and negative frequencies
"""

# YOUR CODE HERE:
# block = matched_output[:4096]
# block_4th = ...  (raise to 4th power)
# fft_result = ...  (FFT)
# freqs = ...  (frequency bins)
# peak_idx = ...  (find peak)
# freq_offset_estimate = ...  (peak_freq / 4)
# t = ...  (time vector)
# freq_corrected = ...  (apply correction)


# ============================================================================
# STEP 4: TIMING SYNCHRONIZATION
# ============================================================================
"""
TODO: Find optimal sampling instant within each symbol period

Why: Signal has 8 samples per symbol. Only ONE of those 8 represents peak.
Due to timing offset at TX, we don't know which sample is best.

Method: Try all phases and pick best (maximum variance method)

Pseudocode:
1. Initialize:
   - best_phase = 0
   - best_variance = 0

2. Loop through all possible phases (0 to 7):
   For each test_phase:

   a. Downsample signal at this phase:
      - Take samples: signal[phase::8]
      - This gives one sample per symbol

   b. Measure "constellation tightness":
      - Calculate variance of absolute values: var(abs(symbols))
      - Higher variance = symbols cluster better around constellation points
      - Lower variance = wrong phase, samples between symbols

   c. If this variance > best_variance:
      - Update best_phase
      - Update best_variance

3. Downsample at optimal phase:
   - symbols = freq_corrected[best_phase::sps]
   - Now have symbol-rate samples

4. Print optimal phase and number of symbols

Alternative methods (more advanced):
- Gardner Timing Error Detector with PLL
- Mueller & Muller algorithm
- Early-Late Gate

Implementation hints:
- Python slicing: array[start::step] takes every 'step' element starting at 'start'
- np.var() calculates variance
- You'll get ~1000 symbols (depending on exact signal length)
"""

# YOUR CODE HERE:
# best_phase = 0
# best_variance = 0
# for test_phase in range(sps):
#     test_symbols = ...  (downsample at this phase)
#     variance = ...  (measure variance)
#     if variance > best_variance:
#         ...  (update best)
#
# symbols_downsampled = ...  (downsample at best phase)


# ============================================================================
# STEP 5: FINE FREQUENCY OFFSET CORRECTION (Optional)
# ============================================================================
"""
TODO: Correct residual frequency offset (if any remains)

Why: Coarse correction may not be perfect. Small residual offset causes
constellation to slowly rotate over time.

Method: Decision-Directed or Frequency-Locked Loop (FLL)

Pseudocode (Decision-Directed):
1. Make hard decisions on symbols (map to nearest constellation point)
2. Compare received phase to expected phase
3. Track phase difference over time
4. Phase slope = residual frequency offset
5. Correct based on estimated slope

For this signal: Coarse correction should be sufficient, so SKIP this step

Note: In production receivers, FLL would continuously track frequency
"""

# SKIPPED FOR THIS EXERCISE
# (Coarse correction handles the 500 Hz offset well enough)


# ============================================================================
# STEP 6: CARRIER PHASE RECOVERY
# ============================================================================
"""
TODO: Estimate and correct unknown carrier phase offset

Why: TX applied random phase rotation. This rotates entire constellation
by fixed angle. Must correct before demodulation.

Method: 4th Power Average Phase

Pseudocode:
1. Raise symbol sequence to 4th power:
   - For each symbol: symbol^4
   - This removes QPSK modulation, leaves only phase offset
   - Why? (e^(jθ) * e^(jφ))^4 = e^(j4φ) where φ is phase offset

2. Calculate average of all 4th-power symbols:
   - avg = mean(symbols_4th)

3. Extract angle:
   - angle_4x = angle(avg)
   - This is 4 times the actual phase offset

4. Estimate phase offset:
   - phase_offset = angle_4x / 4

5. Correct all symbols:
   - Multiply by exp(-j * phase_offset)
   - This rotates constellation back to standard position

6. Print estimated phase offset (radians and degrees)

Alternative methods (more advanced):
- Costas Loop (continuously tracks phase)
- Decision-Directed Phase-Locked Loop

Implementation hints:
- np.angle() extracts phase from complex number
- np.mean() averages complex numbers
- Convert radians to degrees: np.degrees()
"""

# YOUR CODE HERE:
# symbols_4th = ...  (raise to 4th power)
# avg_phase_4x = ...  (angle of average)
# phase_offset_estimate = ...  (divide by 4)
# phase_corrected = ...  (apply correction)


# ============================================================================
# STEP 7: SYMBOL DECISION (DEMODULATION)
# ============================================================================
"""
TODO: Map received symbols to bits

QPSK Constellation (normalized):
  Quadrant 2: (-1+j)/√2  |  Quadrant 1: (+1+j)/√2
         01 (I<0, Q>0)   |        00 (I>0, Q>0)
  -----------------------+------------------------
         10 (I<0, Q<0)   |        11 (I>0, Q<0)
  Quadrant 3: (-1-j)/√2  |  Quadrant 4: (+1-j)/√2

Bit mapping (Gray code - only 1 bit changes between adjacent symbols):
- I>0, Q>0 → 00
- I<0, Q>0 → 01
- I<0, Q<0 → 10
- I>0, Q<0 → 11

Pseudocode:
1. Create empty list for bits

2. For each symbol in phase_corrected:

   a. Extract I (real part) and Q (imaginary part)

   b. Determine quadrant based on signs:
      - If I ≥ 0 and Q ≥ 0: bits = [0, 0]  (Quadrant 1)
      - If I < 0 and Q ≥ 0: bits = [0, 1]  (Quadrant 2)
      - If I < 0 and Q < 0: bits = [1, 0]  (Quadrant 3)
      - If I ≥ 0 and Q < 0: bits = [1, 1]  (Quadrant 4)

   c. Append bits to list

3. Convert list to numpy array

4. Print number of demodulated bits

Implementation hints:
- Use .real and .imag to extract I and Q
- Simple if/elif/else logic
- Each symbol → 2 bits
- 1000 symbols → 2000 bits
"""

# YOUR CODE HERE:
# bits_demod = []
# for symbol in phase_corrected:
#     I = ...
#     Q = ...
#     if I >= 0 and Q >= 0:
#         bits = [0, 0]
#     elif ...:
#         ...
#     bits_demod.extend(bits)
#
# bits_demod = np.array(bits_demod)


# ============================================================================
# STEP 8: PERFORMANCE ANALYSIS & VISUALIZATION
# ============================================================================
"""
TODO: Visualize results and calculate performance metrics

Create 4 plots:
1. Recovered constellation (after phase correction)
   - Scatter plot: phase_corrected (I vs Q)
   - Overlay ideal QPSK points in red

2. Constellation before phase correction
   - Scatter plot: symbols_downsampled (I vs Q)
   - Shows rotation due to phase offset

3. Demodulated bits (first 200)
   - Stem plot of bit values

4. Eye diagram (I channel)
   - Shows signal quality, ISI, timing

Calculate Error Vector Magnitude (EVM):
- For each received symbol:
  * Find nearest ideal constellation point
  * Calculate error = received - ideal
  * EVM = RMS of all errors
- Lower EVM = better quality

Pseudocode:
1. Create 2x2 subplot figure

2. Plot 1 (top-left): Recovered constellation
   - plt.scatter(phase_corrected.real, phase_corrected.imag)
   - Overlay ideal points: [+1+j, -1+j, -1-j, +1-j] / √2
   - Set axis equal, labels, grid

3. Plot 2 (top-right): Before phase correction
   - plt.scatter(symbols_downsampled.real, symbols_downsampled.imag)
   - Overlay ideal points

4. Plot 3 (bottom-left): Bits
   - plt.stem(bits_demod[:200])

5. Plot 4 (bottom-right): Eye diagram
   - Loop through signal in 2-symbol chunks
   - Plot overlapping segments (creates "eye")

6. Calculate EVM:
   - For each symbol, find nearest ideal point
   - Calculate error magnitude
   - EVM_rms = sqrt(mean(errors^2))
   - Convert to percent

7. Print performance metrics

Implementation hints:
- plt.subplot(2, 2, n) for subplots
- plt.scatter() for constellation
- plt.stem() for digital signals
- Eye diagram: overlap many symbol periods
"""

# YOUR CODE HERE:
# import matplotlib.pyplot as plt
#
# fig, axes = plt.subplots(2, 2, figsize=(10, 8))
#
# # Plot 1: Recovered constellation
# ...
#
# # Plot 2: Before phase correction
# ...
#
# # Plot 3: Demodulated bits
# ...
#
# # Plot 4: Eye diagram
# ...
#
# # Calculate EVM
# ...
#
# plt.tight_layout()
# plt.show()


# ============================================================================
# NOTES & TIPS
# ============================================================================
"""
Testing your implementation:
1. Run qpsk-gen.py first to create qpsk_signal.iq
2. Run this demodulator
3. Check constellation plot - should see 4 tight clusters
4. EVM should be < 20% for 15 dB SNR
5. Phase before/after correction shows the correction working

Common issues:
- Frequency offset estimate off by factor of 4? (Forgot to divide by 4)
- Constellation rotated? (Phase correction not working)
- Constellation smeared? (Wrong timing phase selected)
- No clear symbols? (Matched filter not applied correctly)

Key concepts:
- Matched filtering maximizes SNR
- 4th power removes QPSK modulation, reveals offset
- Timing sync finds optimal sampling instant
- Phase recovery aligns constellation
- Gray code mapping minimizes bit errors

Advanced topics to explore:
- Implement Costas Loop for phase tracking
- Gardner Timing Error Detector with loop filter
- Soft decision decoding
- Frame synchronization
- Adaptive equalization
"""

print("\n=== QPSK Demodulator Pseudocode ===")
print("Fill in the YOUR CODE HERE sections to implement receiver")
print("Run qpsk-gen.py first to generate the IQ file")
